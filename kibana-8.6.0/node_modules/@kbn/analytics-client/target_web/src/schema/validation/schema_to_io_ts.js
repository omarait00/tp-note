import _toConsumableArray from "@babel/runtime/helpers/toConsumableArray";
import _slicedToArray from "@babel/runtime/helpers/slicedToArray";
import _objectWithoutProperties from "@babel/runtime/helpers/objectWithoutProperties";
var _excluded = ["DYNAMIC_KEY"];
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0 and the Server Side Public License, v 1; you may not use this file except
 * in compliance with, at your election, the Elastic License 2.0 or the Server
 * Side Public License, v 1.
 */

import * as t from 'io-ts';
import { excess } from './excess';

/**
 * Is it a tuple of t.Mixed?
 * @param schemas Array of io-ts schemas
 */
function isOneOfCandidate(schemas) {
  return schemas.length === 2;
}

/**
 * Converts each {@link SchemaValue} to the io-ts equivalent
 * @param value The {@link SchemaValue} to parse
 */
function schemaValueToIoTs(value) {
  // We need to check the pass_through type on top of everything
  if (value.type === 'pass_through') {
    return t.unknown;
  }
  if ('properties' in value) {
    var _ref = value.properties,
      DYNAMIC_KEY = _ref.DYNAMIC_KEY,
      properties = _objectWithoutProperties(_ref, _excluded);
    var schemas = [schemaObjectToIoTs({
      properties: properties
    })];
    if (DYNAMIC_KEY) {
      schemas.push(t.record(t.string, schemaValueToIoTs(DYNAMIC_KEY)));
    }
    return isOneOfCandidate(schemas) ? t.union(schemas) : schemas[0];
  } else {
    var valueType = value.type; // Copied in here because of TS reasons, it's not available in the `default` case
    switch (valueType) {
      case 'boolean':
        return t["boolean"];
      case 'keyword':
      case 'text':
      case 'date':
        return t.string;
      case 'byte':
      case 'double':
      case 'float':
      case 'integer':
      case 'long':
      case 'short':
        return t.number;
      case 'array':
        if ('items' in value) {
          return t.array(schemaValueToIoTs(value.items));
        }
        throw new Error("Schema type must include the \"items\" declaration.");
      default:
        throw new Error("Unsupported schema type ".concat(valueType, "."));
    }
  }
}

/**
 * Loops through a list of [key, SchemaValue] tuples to convert them into a valid io-ts parameter to define objects.
 * @param entries Array of tuples [key, {@link SchemaValue}]. Typically, coming from Object.entries(SchemaObject).
 */
function entriesToObjectIoTs(entries) {
  return Object.fromEntries(entries.map(function (_ref2) {
    var _ref3 = _slicedToArray(_ref2, 2),
      key = _ref3[0],
      value = _ref3[1];
    try {
      return [key, schemaValueToIoTs(value)];
    } catch (err) {
      err.failedKey = [key].concat(_toConsumableArray(err.failedKey || []));
      throw err;
    }
  }));
}

/**
 * Converts a {@link SchemaObject} to the io-ts equivalent.
 * @param schemaObject The {@link SchemaObject} to parse.
 */
function schemaObjectToIoTs(schemaObject) {
  var objectEntries = Object.entries(schemaObject.properties);
  var requiredFields = objectEntries.filter(function (_ref4) {
    var _ref5 = _slicedToArray(_ref4, 2),
      key = _ref5[0],
      _meta = _ref5[1]._meta;
    return (_meta === null || _meta === void 0 ? void 0 : _meta.optional) !== true;
  });
  var optionalFields = objectEntries.filter(function (_ref6) {
    var _ref7 = _slicedToArray(_ref6, 2),
      key = _ref7[0],
      _meta = _ref7[1]._meta;
    return (_meta === null || _meta === void 0 ? void 0 : _meta.optional) === true;
  });
  return excess(t.intersection([t["interface"](entriesToObjectIoTs(requiredFields)), t.partial(entriesToObjectIoTs(optionalFields))]));
}

/**
 * Converts a {@link RootSchema} to an io-ts validation object.
 * @param rootSchema The {@link RootSchema} to be parsed.
 */
export function schemaToIoTs(rootSchema) {
  try {
    return schemaObjectToIoTs({
      properties: rootSchema
    });
  } catch (err) {
    if (err.failedKey) {
      err.message = "Malformed schema for key [".concat(err.failedKey.join('.'), "]: ").concat(err.message);
    }
    throw err;
  }
}