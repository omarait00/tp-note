"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createRootRoute = createRootRoute;
var _https = _interopRequireDefault(require("https"));
var _url = require("url");
var _nodeFetch = _interopRequireDefault(require("node-fetch"));
var _kibana_config = require("../kibana_config");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0 and the Server Side Public License, v 1; you may not use this file except
 * in compliance with, at your election, the Elastic License 2.0 or the Server
 * Side Public License, v 1.
 */

const HTTPS = 'https:';
const GATEWAY_ROOT_ROUTE = '/';
const KIBANA_ROOT_ROUTE = '/';
function createRootRoute({
  config,
  log
}) {
  const kibanaConfig = new _kibana_config.KibanaConfig(config.atPathSync('kibana'));
  const fetch = configureFetch(kibanaConfig);
  return {
    method: 'GET',
    path: GATEWAY_ROOT_ROUTE,
    handler: async (req, h) => {
      const responses = await fetchKibanaRoots({
        fetch,
        kibanaConfig,
        log
      });
      const {
        body,
        statusCode
      } = mergeResponses(responses);
      return h.response(body).type('application/json').code(statusCode);
    }
  };
}
async function fetchKibanaRoots({
  fetch,
  kibanaConfig,
  log
}) {
  const requests = await Promise.allSettled(kibanaConfig.hosts.map(async host => {
    log.debug(`Fetching response from ${host}${KIBANA_ROOT_ROUTE}`);
    return fetch(`${host}${KIBANA_ROOT_ROUTE}`);
  }));
  return requests.map((r, i) => {
    if (r.status === 'rejected') {
      log.error(`No response from ${kibanaConfig.hosts[i]}${KIBANA_ROOT_ROUTE}`);
    } else {
      log.info(`Got response from ${kibanaConfig.hosts[i]}${KIBANA_ROOT_ROUTE}: ${JSON.stringify(r.value.status)}`);
    }
    return r;
  });
}
function mergeResponses(responses) {
  let statusCode = 200;
  for (const response of responses) {
    if (response.status === 'rejected' || !isHealthyResponse(response.value.status, response.value.headers)) {
      statusCode = 503;
    }
  }
  return {
    body: {},
    // The control plane health check ignores the body, so we do the same
    statusCode
  };
}
function isHealthyResponse(statusCode, headers) {
  return isSuccess(statusCode) || isUnauthorized(statusCode, headers);
}
function isUnauthorized(statusCode, headers) {
  return statusCode === 401 && headers.has('www-authenticate');
}
function isSuccess(statusCode) {
  return statusCode >= 200 && statusCode <= 299 || statusCode === 302;
}
function generateAgentConfig(sslConfig) {
  const options = {
    ca: sslConfig.certificateAuthorities,
    cert: sslConfig.certificate
  };
  const verificationMode = sslConfig.verificationMode;
  switch (verificationMode) {
    case 'none':
      options.rejectUnauthorized = false;
      break;
    case 'certificate':
      options.rejectUnauthorized = true;
      // by default, NodeJS is checking the server identify
      options.checkServerIdentity = () => undefined;
      break;
    case 'full':
      options.rejectUnauthorized = true;
      break;
    default:
      throw new Error(`Unknown ssl verificationMode: ${verificationMode}`);
  }
  return options;
}
function configureFetch(kibanaConfig) {
  let agent;
  return async url => {
    const {
      protocol
    } = new _url.URL(url);
    if (protocol === HTTPS && !agent) {
      agent = new _https.default.Agent(generateAgentConfig(kibanaConfig.ssl));
    }
    const controller = new AbortController();
    const timeoutId = setTimeout(() => controller.abort(), kibanaConfig.requestTimeout.asMilliseconds());
    const fetchOptions = {
      ...(protocol === HTTPS && {
        agent
      }),
      signal: controller.signal,
      redirect: 'manual'
    };
    try {
      const response = await (0, _nodeFetch.default)(url, fetchOptions);
      clearTimeout(timeoutId);
      return response;
    } catch (e) {
      clearTimeout(timeoutId);
      throw e;
    }
  };
}