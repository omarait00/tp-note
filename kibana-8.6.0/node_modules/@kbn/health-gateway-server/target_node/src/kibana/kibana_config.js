"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.config = exports.KibanaConfig = void 0;
var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
var _fs = require("fs");
var _configSchema = require("@kbn/config-schema");
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0 and the Server Side Public License, v 1; you may not use this file except
 * in compliance with, at your election, the Elastic License 2.0 or the Server
 * Side Public License, v 1.
 */

const hostURISchema = _configSchema.schema.uri({
  scheme: ['http', 'https']
});
const configSchema = _configSchema.schema.object({
  hosts: _configSchema.schema.arrayOf(hostURISchema, {
    minSize: 1
  }),
  requestTimeout: _configSchema.schema.duration({
    defaultValue: '30s'
  }),
  ssl: _configSchema.schema.object({
    verificationMode: _configSchema.schema.oneOf([_configSchema.schema.literal('none'), _configSchema.schema.literal('certificate'), _configSchema.schema.literal('full')], {
      defaultValue: 'full'
    }),
    certificateAuthorities: _configSchema.schema.maybe(_configSchema.schema.oneOf([_configSchema.schema.string(), _configSchema.schema.arrayOf(_configSchema.schema.string(), {
      minSize: 1
    })])),
    certificate: _configSchema.schema.maybe(_configSchema.schema.string())
  })
});
const config = {
  path: 'kibana',
  schema: configSchema
};
exports.config = config;
class KibanaConfig {
  /**
   * Kibana hosts that the gateway will connect to.
   */

  /**
   * Timeout after which HTTP requests to the Kibana hosts will be aborted.
   */

  /**
   * Settings to configure SSL connection between the gateway and Kibana hosts.
   */

  constructor(rawConfig) {
    (0, _defineProperty2.default)(this, "hosts", void 0);
    (0, _defineProperty2.default)(this, "requestTimeout", void 0);
    (0, _defineProperty2.default)(this, "ssl", void 0);
    this.hosts = rawConfig.hosts;
    this.requestTimeout = rawConfig.requestTimeout;
    const {
      verificationMode
    } = rawConfig.ssl;
    const {
      certificate,
      certificateAuthorities
    } = readKeyAndCerts(rawConfig);
    this.ssl = {
      certificate,
      certificateAuthorities,
      verificationMode
    };
  }
}
exports.KibanaConfig = KibanaConfig;
const readKeyAndCerts = rawConfig => {
  let certificate;
  let certificateAuthorities;
  const addCAs = ca => {
    if (ca && ca.length) {
      certificateAuthorities = [...(certificateAuthorities || []), ...ca];
    }
  };
  if (rawConfig.ssl.certificate) {
    certificate = readFile(rawConfig.ssl.certificate);
  }
  const ca = rawConfig.ssl.certificateAuthorities;
  if (ca) {
    const parsed = [];
    const paths = Array.isArray(ca) ? ca : [ca];
    if (paths.length > 0) {
      for (const path of paths) {
        parsed.push(readFile(path));
      }
      addCAs(parsed);
    }
  }
  return {
    certificate,
    certificateAuthorities
  };
};
const readFile = file => (0, _fs.readFileSync)(file, 'utf8');