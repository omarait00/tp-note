import _typeof from "@babel/runtime/helpers/typeof";
import _createForOfIteratorHelper from "@babel/runtime/helpers/createForOfIteratorHelper";
import _inherits from "@babel/runtime/helpers/inherits";
import _setPrototypeOf from "@babel/runtime/helpers/setPrototypeOf";
function _wrapRegExp() { _wrapRegExp = function _wrapRegExp(re, groups) { return new BabelRegExp(re, void 0, groups); }; var _super = RegExp.prototype, _groups = new WeakMap(); function BabelRegExp(re, flags, groups) { var _this = new RegExp(re, flags); return _groups.set(_this, groups || _groups.get(re)), _setPrototypeOf(_this, BabelRegExp.prototype); } function buildGroups(result, re) { var g = _groups.get(re); return Object.keys(g).reduce(function (groups, name) { var i = g[name]; if ("number" == typeof i) groups[name] = result[i];else { for (var k = 0; void 0 === result[i[k]] && k + 1 < i.length;) { k++; } groups[name] = result[i[k]]; } return groups; }, Object.create(null)); } return _inherits(BabelRegExp, RegExp), BabelRegExp.prototype.exec = function (str) { var result = _super.exec.call(this, str); if (result) { result.groups = buildGroups(result, this); var indices = result.indices; indices && (indices.groups = buildGroups(indices, this)); } return result; }, BabelRegExp.prototype[Symbol.replace] = function (str, substitution) { if ("string" == typeof substitution) { var groups = _groups.get(this); return _super[Symbol.replace].call(this, str, substitution.replace(/\$<([^>]+)>/g, function (_, name) { var group = groups[name]; return "$" + (Array.isArray(group) ? group.join("$") : group); })); } if ("function" == typeof substitution) { var _this = this; return _super[Symbol.replace].call(this, str, function () { var args = arguments; return "object" != _typeof(args[args.length - 1]) && (args = [].slice.call(args)).push(buildGroups(args, _this)), substitution.apply(this, args); }); } return _super[Symbol.replace].call(this, str, substitution); }, _wrapRegExp.apply(this, arguments); }
/*
 * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one
 * or more contributor license agreements. Licensed under the Elastic License
 * 2.0 and the Server Side Public License, v 1; you may not use this file except
 * in compliance with, at your election, the Elastic License 2.0 or the Server
 * Side Public License, v 1.
 */

import moment from 'moment-timezone';
import { last } from 'lodash';
var dateRegExp = /*#__PURE__*/_wrapRegExp(/%date(\{([^}]+)\})?(\{([^}]+)\})?/g, {
  format: 2,
  timezone: 4
});
var formats = {
  ISO8601: 'ISO8601',
  ISO8601_TZ: 'ISO8601_TZ',
  ABSOLUTE: 'ABSOLUTE',
  UNIX: 'UNIX',
  UNIX_MILLIS: 'UNIX_MILLIS'
};
function formatDate(date) {
  var dateFormat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : formats.ISO8601_TZ;
  var timezone = arguments.length > 2 ? arguments[2] : undefined;
  var momentDate = moment(date);
  momentDate.tz(timezone !== null && timezone !== void 0 ? timezone : moment.tz.guess());
  switch (dateFormat) {
    case formats.ISO8601:
      return momentDate.toISOString();
    case formats.ISO8601_TZ:
      return momentDate.format('YYYY-MM-DDTHH:mm:ss.SSSZ');
    case formats.ABSOLUTE:
      return momentDate.format('HH:mm:ss.SSS');
    case formats.UNIX:
      return momentDate.format('X');
    case formats.UNIX_MILLIS:
      return momentDate.format('x');
    default:
      throw new Error("Unknown format: ".concat(dateFormat));
  }
}
function validateDateFormat(input) {
  if (!Reflect.has(formats, input)) {
    throw new Error("Date format expected one of ".concat(Reflect.ownKeys(formats).join(', '), ", but given: ").concat(input));
  }
}
function validateTimezone(timezone) {
  if (moment.tz.zone(timezone)) return;
  throw new Error("Unknown timezone: ".concat(timezone));
}
function validate(rawString) {
  var _iterator = _createForOfIteratorHelper(rawString.matchAll(dateRegExp)),
    _step;
  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var matched = _step.value;
      var _ref = matched.groups,
        format = _ref.format,
        timezone = _ref.timezone;
      if (format) {
        validateDateFormat(format);
      }
      if (timezone) {
        validateTimezone(timezone);
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }
}
export var DateConversion = {
  pattern: dateRegExp,
  convert: function convert(record, highlight) {
    for (var _len = arguments.length, matched = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
      matched[_key - 2] = arguments[_key];
    }
    var groups = last(matched);
    var format = groups.format,
      timezone = groups.timezone;
    return formatDate(record.timestamp, format, timezone);
  },
  validate: validate
};